<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Production Client - Protocol %</title>
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        .main-content {
            padding: 120px 0 80px;
            min-height: 100vh;
        }

        .page-header {
            text-align: center;
            margin-bottom: 60px;
        }

        .page-title {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 16px;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.03em;
        }

        .page-subtitle {
            font-size: 1.25rem;
            color: var(--text-secondary);
            max-width: 600px;
            margin: 0 auto;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 32px;
            margin-bottom: 40px;
        }

        .control-panel {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: var(--border-radius-lg);
            padding: 32px;
            backdrop-filter: blur(10px);
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 24px;
        }

        .panel-icon {
            width: 40px;
            height: 40px;
            padding: 8px;
            background: var(--accent-gradient);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-icon svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .panel-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: 12px;
            background: var(--dark-bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: rgba(79, 172, 254, 0.5);
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .form-range {
            width: 100%;
            height: 6px;
            background: var(--card-border);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .form-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-gradient);
            border-radius: 50%;
            cursor: pointer;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }

        .metric-item {
            background: var(--dark-bg);
            border: 1px solid var(--card-border);
            border-radius: var(--border-radius);
            padding: 16px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 4px;
        }

        .metric-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 32px;
            margin-bottom: 40px;
        }

        .analysis-panel {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: var(--border-radius-lg);
            padding: 32px;
            backdrop-filter: blur(10px);
        }

        .canvas-container {
            margin: 20px 0;
        }

        .canvas-container canvas {
            width: 100%;
            height: 150px;
            background: var(--dark-bg);
            border: 1px solid var(--card-border);
            border-radius: var(--border-radius);
            margin-bottom: 12px;
        }

        .frequency-indicator {
            height: 6px;
            background: var(--card-border);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .frequency-indicator .active {
            height: 100%;
            background: var(--accent-gradient);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .decoder-log {
            background: var(--dark-bg);
            border: 1px solid var(--card-border);
            border-radius: var(--border-radius);
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Fira Code', 'Monaco', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid var(--card-border);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-timestamp {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .log-element {
            color: var(--success-color);
            font-weight: 600;
        }

        .log-frequency {
            color: var(--accent-color);
            font-weight: 600;
        }

        .log-text {
            color: var(--text-primary);
        }

        .preview-section {
            grid-column: 1 / -1;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: var(--border-radius-lg);
            padding: 32px;
            backdrop-filter: blur(10px);
        }

        .html-preview {
            width: 100%;
            height: 400px;
            border: 1px solid var(--card-border);
            border-radius: var(--border-radius);
            background: white;
        }

        .preview-placeholder {
            background: var(--dark-bg);
            border: 1px solid var(--card-border);
            border-radius: var(--border-radius);
            padding: 40px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .page-title {
                font-size: 2.5rem;
            }

            .button-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="bg-animation"></div>
    
    <!-- Navigation -->
    <nav class="nav" id="navbar">
        <div class="nav-content">
            <div class="logo">Protocol %</div>
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="generator.html">Generator</a></li>
                <li><a href="decoder.html">Decoder</a></li>
                <li><a href="frequency_analyzer.html">Analyzer</a></li>
                <li><a href="about.html">About</a></li>
                <li>
                    <a href="https://github.com/nia-cloud-official/httpmp3" target="_blank" class="btn-github">
                        <svg viewBox="0 0 24 24">
                            <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"/>
                        </svg>
                        GitHub
                    </a>
                </li>
            </ul>
        </div>
    </nav>

    <main class="main-content">
        <div class="container">
            <!-- Page Header -->
            <div class="page-header">
                <h1 class="page-title">Production Client</h1>
                <p class="page-subtitle">
                    Real-time HTML decoding from audio signals with advanced visualization and monitoring
                </p>
            </div>

            <!-- Control Panels -->
            <div class="controls-grid">
                <!-- Audio Source Panel -->
                <div class="control-panel">
                    <div class="panel-header">
                        <div class="panel-icon">
                            <svg viewBox="0 0 24 24">
                                <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"/>
                            </svg>
                        </div>
                        <h3 class="panel-title">Audio Source</h3>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="sourceType">Source Type</label>
                        <select id="sourceType" class="form-select">
                            <option value="file">Audio File</option>
                            <option value="microphone">Live Microphone</option>
                            <option value="server">Server Stream</option>
                            <option value="url">Remote URL</option>
                        </select>
                    </div>
                    
                    <div class="form-group" id="fileGroup">
                        <label class="form-label" for="audioFile">Select Audio File</label>
                        <input type="file" id="audioFile" class="form-input" accept="audio/*">
                    </div>
                    
                    <div class="form-group" id="serverGroup" style="display: none;">
                        <label class="form-label" for="serverFile">HTML Filename</label>
                        <input type="text" id="serverFile" class="form-input" placeholder="example.html">
                    </div>
                    
                    <div class="form-group" id="urlGroup" style="display: none;">
                        <label class="form-label" for="remoteUrl">Remote URL</label>
                        <input type="url" id="remoteUrl" class="form-input" placeholder="https://example.com/audio.wav">
                    </div>
                    
                    <div class="button-group">
                        <button id="startBtn" class="btn btn-primary">
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                            </svg>
                            Start Decoding
                        </button>
                        <button id="stopBtn" class="btn btn-danger" disabled>
                            <svg class="icon" viewBox="0 0 24 24">
                                <path d="M18,18H6V6H18V18Z"/>
                            </svg>
                            Stop
                        </button>
                    </div>
                </div>
                
                <!-- Decoder Settings Panel -->
                <div class="control-panel">
                    <div class="panel-header">
                        <div class="panel-icon">
                            <svg viewBox="0 0 24 24">
                                <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
                            </svg>
                        </div>
                        <h3 class="panel-title">Decoder Settings</h3>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="decoderMode">Mode</label>
                        <select id="decoderMode" class="form-select">
                            <option value="production">Production</option>
                            <option value="ultrasonic">Ultrasonic</option>
                            <option value="debug">Debug</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="fftSize">FFT Size</label>
                        <select id="fftSize" class="form-select">
                            <option value="2048">2048</option>
                            <option value="4096" selected>4096</option>
                            <option value="8192">8192</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="threshold">Detection Threshold</label>
                        <input type="range" id="threshold" class="form-range" min="0" max="100" value="30">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="smoothing">Smoothing</label>
                        <input type="range" id="smoothing" class="form-range" min="0" max="1" step="0.1" value="0.3">
                    </div>
                </div>
                
                <!-- Status & Metrics Panel -->
                <div class="control-panel">
                    <div class="panel-header">
                        <div class="panel-icon">
                            <svg viewBox="0 0 24 24">
                                <path d="M16,6L18.29,8.29L13.41,13.17L9.41,9.17L2,16.59L3.41,18L9.41,12L13.41,16L19.71,9.71L22,12V6H16Z"/>
                            </svg>
                        </div>
                        <h3 class="panel-title">Status & Metrics</h3>
                    </div>
                    
                    <div id="status" class="status-message status-info">Ready to decode</div>
                    
                    <div class="metrics-grid">
                        <div class="metric-item">
                            <div class="metric-value" id="dominantFreq">-</div>
                            <div class="metric-label">Frequency (Hz)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="signalStrength">-</div>
                            <div class="metric-label">Signal (dB)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="decodedElements">0</div>
                            <div class="metric-label">Elements</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="errorRate">0%</div>
                            <div class="metric-label">Error Rate</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Analysis and Log Panels -->
            <div class="main-grid">
                <!-- Audio Analysis Panel -->
                <div class="analysis-panel">
                    <div class="panel-header">
                        <div class="panel-icon">
                            <svg viewBox="0 0 24 24">
                                <path d="M16,6L18.29,8.29L13.41,13.17L9.41,9.17L2,16.59L3.41,18L9.41,12L13.41,16L19.71,9.71L22,12V6H16Z"/>
                            </svg>
                        </div>
                        <h3 class="panel-title">Audio Analysis</h3>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="waveformCanvas"></canvas>
                        <canvas id="spectrogramCanvas"></canvas>
                        <div class="frequency-indicator">
                            <div class="active" id="frequencyIndicator"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Decoder Log Panel -->
                <div class="analysis-panel">
                    <div class="panel-header">
                        <div class="panel-icon">
                            <svg viewBox="0 0 24 24">
                                <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                            </svg>
                        </div>
                        <h3 class="panel-title">Decoder Log</h3>
                    </div>
                    
                    <div class="decoder-log" id="decoderLog">
                        <div class="log-entry">
                            <span class="log-timestamp">Ready</span> - 
                            <span class="log-text">Waiting for audio input...</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- HTML Preview Section -->
            <div class="preview-section">
                <div class="panel-header">
                    <div class="panel-icon">
                        <svg viewBox="0 0 24 24">
                            <path d="M12,3L2,12H5V20H19V12H22L12,3M12,7.7L17,12V18H15V14H9V18H7V12L12,7.7Z"/>
                        </svg>
                    </div>
                    <h3 class="panel-title">Live HTML Preview</h3>
                </div>
                
                <iframe class="html-preview" id="htmlPreview" style="display: none;"></iframe>
                <div id="htmlPreviewPlaceholder" class="preview-placeholder">
                    Decoded HTML will appear here in real-time as audio is processed...
                </div>
            </div>
        </div>
    </main>

    <script>
        class ProductionSoundDecoder {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.source = null;
                this.isDecoding = false;
                this.frequencies = {};
                this.decodedHTML = '';
                this.elementCount = 0;
                this.errorCount = 0;
                this.lastFrequency = 0;
                this.frequencyBuffer = [];
                this.state = 'waiting';
                this.htmlStack = [];
                this.currentElement = null;
                this.frameStarted = false;
                
                this.initializeEventListeners();
                this.loadFrequencyMap();
            }
            
            async loadFrequencyMap() {
                // Use default frequencies directly - no server needed
                this.frequencies = this.getDefaultFrequencies();
                this.log('Frequency map loaded', 'success');
            }
            
            getDefaultFrequencies() {
                return {
                    frame_start: [440, 554, 659],
                    frame_end: [440, 349, 262],
                    http_200: [523, 659, 784],
                    html_open: 440,
                    html_close: 415,
                    head_open: 660,
                    head_close: 622,
                    body_open: 880,
                    body_close: 831,
                    title: [523, 659, 784, 1047],
                    h1: 1047,
                    h2: 932,
                    h3: 831,
                    p: 698,
                    div: 622,
                    a: [392, 494, 587],
                    fsk_0: 2000,
                    fsk_1: 2400,
                    sync: 2800,
                    block_start: 1760,
                    block_end: 1568
                };
            }
            
            initializeEventListeners() {
                document.getElementById('sourceType').addEventListener('change', this.handleSourceChange.bind(this));
                document.getElementById('startBtn').addEventListener('click', this.startDecoding.bind(this));
                document.getElementById('stopBtn').addEventListener('click', this.stopDecoding.bind(this));
                document.getElementById('decoderMode').addEventListener('change', this.updateDecoderSettings.bind(this));
                document.getElementById('threshold').addEventListener('input', this.updateDecoderSettings.bind(this));
                document.getElementById('smoothing').addEventListener('input', this.updateDecoderSettings.bind(this));
            }
            
            handleSourceChange() {
                const sourceType = document.getElementById('sourceType').value;
                
                document.getElementById('fileGroup').style.display = sourceType === 'file' ? 'block' : 'none';
                document.getElementById('serverGroup').style.display = sourceType === 'server' ? 'block' : 'none';
                document.getElementById('urlGroup').style.display = sourceType === 'url' ? 'block' : 'none';
            }
            
            updateDecoderSettings() {
                if (this.analyser) {
                    const smoothing = parseFloat(document.getElementById('smoothing').value);
                    this.analyser.smoothingTimeConstant = smoothing;
                }
            }
            
            async startDecoding() {
                try {
                    this.updateStatus('Initializing audio context...', 'info');
                    
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    const sourceType = document.getElementById('sourceType').value;
                    
                    switch (sourceType) {
                        case 'file':
                            await this.loadAudioFile();
                            break;
                        case 'microphone':
                            await this.startMicrophoneCapture();
                            break;
                        case 'server':
                            await this.fetchFromServer();
                            break;
                        case 'url':
                            await this.fetchFromURL();
                            break;
                    }
                    
                    this.setupAnalyser();
                    this.isDecoding = true;
                    this.startAnalysis();
                    
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    
                    this.updateStatus('Decoding audio...', 'success');
                    
                } catch (error) {
                    this.updateStatus('Error: ' + error.message, 'error');
                    this.log('Decoder error: ' + error.message, 'error');
                }
            }
            
            async loadAudioFile() {
                const fileInput = document.getElementById('audioFile');
                if (!fileInput.files[0]) {
                    throw new Error('Please select an audio file');
                }
                
                this.updateStatus('Loading audio file...', 'info');
                
                const arrayBuffer = await fileInput.files[0].arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                
                this.source = this.audioContext.createBufferSource();
                this.source.buffer = audioBuffer;
                this.source.loop = false;
                
                this.log(`Loaded audio file: ${fileInput.files[0].name}`, 'success');
            }
            
            async startMicrophoneCapture() {
                this.updateStatus('Requesting microphone access...', 'info');
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 44100,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });
                
                this.source = this.audioContext.createMediaStreamSource(stream);
                this.log('Microphone capture started', 'success');
            }
            
            async fetchFromServer() {
                throw new Error('Server mode not available in standalone version');
            }
            
            async fetchFromURL() {
                const url = document.getElementById('remoteUrl').value;
                if (!url) {
                    throw new Error('Please enter a URL');
                }
                
                this.updateStatus('Fetching from URL...', 'info');
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch: ${response.status}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                
                this.source = this.audioContext.createBufferSource();
                this.source.buffer = audioBuffer;
                
                this.log(`Fetched from URL: ${url}`, 'success');
            }
            
            setupAnalyser() {
                const fftSize = parseInt(document.getElementById('fftSize').value);
                const smoothing = parseFloat(document.getElementById('smoothing').value);
                
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = fftSize;
                this.analyser.smoothingTimeConstant = smoothing;
                this.analyser.minDecibels = -90;
                this.analyser.maxDecibels = -10;
                
                if (this.source) {
                    this.source.connect(this.analyser);
                    
                    if (this.source.start) {
                        this.source.start(0);
                    }
                }
            }
            
            startAnalysis() {
                const bufferLength = this.analyser.frequencyBinCount;
                const frequencyData = new Uint8Array(bufferLength);
                const timeData = new Uint8Array(bufferLength);
                
                const analyze = () => {
                    if (!this.isDecoding) return;
                    
                    this.analyser.getByteFrequencyData(frequencyData);
                    this.analyser.getByteTimeDomainData(timeData);
                    
                    this.updateVisualizations(frequencyData, timeData);
                    this.processAudioData(frequencyData);
                    
                    requestAnimationFrame(analyze);
                };
                
                analyze();
            }
            
            updateVisualizations(frequencyData, timeData) {
                this.drawWaveform(timeData);
                this.drawSpectrogram(frequencyData);
                this.updateMetrics(frequencyData);
            }
            
            drawWaveform(timeData) {
                const canvas = document.getElementById('waveformCanvas');
                const ctx = canvas.getContext('2d');
                const width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                const height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, width, height);
                
                ctx.strokeStyle = '#58a6ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const sliceWidth = (width / window.devicePixelRatio) / timeData.length;
                let x = 0;
                
                for (let i = 0; i < timeData.length; i++) {
                    const v = timeData[i] / 128.0;
                    const y = v * (height / window.devicePixelRatio) / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
            }
            
            drawSpectrogram(frequencyData) {
                const canvas = document.getElementById('spectrogramCanvas');
                const ctx = canvas.getContext('2d');
                const width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                const height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                // Shift existing data left
                const imageData = ctx.getImageData(1, 0, width - 1, height);
                ctx.putImageData(imageData, 0, 0);
                
                // Draw new column
                const displayWidth = width / window.devicePixelRatio;
                const displayHeight = height / window.devicePixelRatio;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    const value = frequencyData[i];
                    const percent = value / 255;
                    
                    // Color mapping: blue (low) to red (high)
                    const hue = (1 - percent) * 240;
                    const saturation = 100;
                    const lightness = percent * 50;
                    
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    
                    const y = displayHeight - (i / frequencyData.length) * displayHeight;
                    const barHeight = displayHeight / frequencyData.length;
                    
                    ctx.fillRect(displayWidth - 1, y, 1, barHeight);
                }
            }
            
            updateMetrics(frequencyData) {
                // Find dominant frequency
                let maxIndex = 0;
                let maxValue = 0;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    if (frequencyData[i] > maxValue) {
                        maxValue = frequencyData[i];
                        maxIndex = i;
                    }
                }
                
                const frequency = (maxIndex * this.audioContext.sampleRate) / (this.analyser.fftSize * 2);
                const strength = 20 * Math.log10(maxValue / 255);
                
                document.getElementById('dominantFreq').textContent = frequency.toFixed(1);
                document.getElementById('signalStrength').textContent = strength.toFixed(1);
                document.getElementById('decodedElements').textContent = this.elementCount;
                
                const errorRate = this.elementCount > 0 ? (this.errorCount / this.elementCount * 100) : 0;
                document.getElementById('errorRate').textContent = errorRate.toFixed(1) + '%';
                
                // Update frequency indicator
                const indicator = document.getElementById('frequencyIndicator');
                const maxFreq = this.audioContext.sampleRate / 2;
                const percent = (frequency / maxFreq) * 100;
                indicator.style.width = percent + '%';
            }
            
            processAudioData(frequencyData) {
                const threshold = parseInt(document.getElementById('threshold').value);
                const dominantFreq = this.getDominantFrequency(frequencyData, threshold);
                
                if (dominantFreq > 0 && Math.abs(dominantFreq - this.lastFrequency) > 100) {
                    this.lastFrequency = dominantFreq;
                    
                    const element = this.identifyElement(dominantFreq);
                    
                    if (element && this.shouldProcessElement(element)) {
                        this.processElement(element, dominantFreq);
                    }
                }
            }
            
            shouldProcessElement(element) {
                const now = Date.now();
                if (!this.lastElementTime) this.lastElementTime = {};
                
                // Prevent same element from being processed too frequently
                if (this.lastElementTime[element] && (now - this.lastElementTime[element]) < 500) {
                    return false;
                }
                
                this.lastElementTime[element] = now;
                return true;
            }
            
            getDominantFrequency(frequencyData, threshold) {
                let maxIndex = 0;
                let maxValue = 0;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    if (frequencyData[i] > maxValue && frequencyData[i] > threshold) {
                        maxValue = frequencyData[i];
                        maxIndex = i;
                    }
                }
                
                if (maxValue < threshold) return 0;
                
                return (maxIndex * this.audioContext.sampleRate) / (this.analyser.fftSize * 2);
            }
            
            identifyElement(frequency) {
                const tolerance = 30; // Tighter tolerance for better accuracy
                let bestMatch = null;
                let bestDistance = Infinity;
                
                for (const [element, freq] of Object.entries(this.frequencies)) {
                    if (Array.isArray(freq)) {
                        for (const f of freq) {
                            const distance = Math.abs(frequency - f);
                            if (distance < tolerance && distance < bestDistance) {
                                bestMatch = element;
                                bestDistance = distance;
                            }
                        }
                    } else {
                        const distance = Math.abs(frequency - freq);
                        if (distance < tolerance && distance < bestDistance) {
                            bestMatch = element;
                            bestDistance = distance;
                        }
                    }
                }
                
                return bestMatch;
            }
            
            processElement(element, frequency) {
                this.elementCount++;
                this.log(`${frequency.toFixed(1)}Hz â†’ ${element}`, 'element');
                
                // Initialize HTML structure if not already done
                if (!this.decodedHTML || this.decodedHTML.length === 0) {
                    this.decodedHTML = '<!DOCTYPE html>\n<html>\n<head>\n<title>Decoded from Audio</title>\n</head>\n<body>\n<h1>Audio Protocol Decoder</h1>\n';
                    this.state = 'decoding';
                    this.log('HTML structure initialized', 'success');
                    this.updateHTMLPreview(); // Force update immediately
                }
                
                switch (element) {
                    case 'frame_start':
                        if (this.state !== 'decoding') {
                            this.decodedHTML = '<!DOCTYPE html>\n<html>\n<head>\n<title>Frame Started</title>\n</head>\n<body>\n<h1>Frame Started</h1>\n';
                            this.state = 'decoding';
                            this.log('Frame started - building HTML structure', 'success');
                        }
                        this.decodedHTML += '<p>Frame initialization complete</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'http_200':
                        this.log('HTTP 200 OK received', 'success');
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<div style="background: #d4edda; color: #155724; padding: 10px; margin: 5px 0; border-radius: 4px;">HTTP 200 OK - Connection successful</div>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'html_open':
                        this.decodedHTML += '<p>HTML document opened</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'head_open':
                        this.decodedHTML += '<p>Head section opened</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'title':
                        this.decodedHTML += '<p>Title element processed</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'head_close':
                        this.decodedHTML += '<p>Head section closed</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'body_open':
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<div style="background: #cce5ff; color: #004085; padding: 15px; margin: 10px 0; border-radius: 8px;">\n';
                            this.decodedHTML += '<h2>Body Section Detected!</h2>\n';
                            this.decodedHTML += '<p>This content was successfully decoded from audio frequencies.</p>\n';
                            this.decodedHTML += '<p><strong>Frequency:</strong> ' + frequency.toFixed(1) + 'Hz</p>\n';
                            this.decodedHTML += '</div>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'h1':
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<h1 style="color: #007bff;">Hello from Audio Signal!</h1>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'p':
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<p style="font-size: 16px; color: #333;">This paragraph was transmitted via audio protocol</p>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'body_close':
                        this.decodedHTML += '<p>Body section closing...</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'html_close':
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<div style="background: #f8f9fa; color: #495057; padding: 15px; margin: 10px 0; border-radius: 8px; border: 2px solid #28a745;">\n';
                            this.decodedHTML += '<h3>HTML Document Complete!</h3>\n';
                            this.decodedHTML += '<p>Successfully decoded complete HTML structure from audio signal.</p>\n';
                            this.decodedHTML += '<p><em>Transmission completed at ' + new Date().toLocaleTimeString() + '</em></p>\n';
                            this.decodedHTML += '</div>\n';
                            
                            // Ensure proper closing
                            if (!this.decodedHTML.includes('</body>')) {
                                this.decodedHTML += '</body>\n';
                            }
                            if (!this.decodedHTML.includes('</html>')) {
                                this.decodedHTML += '</html>';
                            }
                            this.log('HTML document completed!', 'success');
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'frame_end':
                        this.state = 'complete';
                        this.log('Frame completed successfully', 'success');
                        this.updateStatus('Decoding completed - HTML structure built!', 'success');
                        // Add final completion message
                        if (this.decodedHTML && !this.decodedHTML.includes('Frame completed')) {
                            this.decodedHTML += '<div style="background: #28a745; color: white; padding: 20px; margin: 10px 0; border-radius: 8px; text-align: center;">\n';
                            this.decodedHTML += '<h2>TRANSMISSION COMPLETE</h2>\n';
                            this.decodedHTML += '<p>All audio signals successfully decoded!</p>\n';
                            this.decodedHTML += '</div>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    default:
                        if (this.state === 'decoding') {
                            this.decodedHTML += `<div style="background: #fff3cd; color: #856404; padding: 8px; margin: 3px 0; border-radius: 4px;">Signal: ${element} (${frequency.toFixed(1)}Hz)</div>\n`;
                            this.updateHTMLPreview();
                        }
                        this.log(`Processing: ${element}`, 'info');
                }
            }
            
            updateHTMLPreview() {
                const iframe = document.getElementById('htmlPreview');
                const placeholder = document.getElementById('htmlPreviewPlaceholder');
                
                // Always log what we're trying to display
                this.log(`Updating preview - HTML length: ${this.decodedHTML ? this.decodedHTML.length : 0}`, 'info');
                
                if (this.decodedHTML && this.decodedHTML.trim().length > 0) {
                    // Hide placeholder and show iframe
                    placeholder.style.display = 'none';
                    iframe.style.display = 'block';
                    
                    // Method 1: Try srcdoc first (more reliable)
                    try {
                        iframe.srcdoc = this.decodedHTML;
                        this.log('HTML written to iframe via srcdoc', 'success');
                        return;
                    } catch (error) {
                        this.log('srcdoc failed: ' + error.message, 'error');
                    }
                    
                    // Method 2: Try contentDocument.write
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        if (iframeDoc) {
                            iframeDoc.open();
                            iframeDoc.write(this.decodedHTML);
                            iframeDoc.close();
                            this.log('HTML written to iframe via document.write', 'success');
                            return;
                        }
                    } catch (error) {
                        this.log('document.write failed: ' + error.message, 'error');
                    }
                    
                    // Method 3: Fallback - show as formatted text
                    iframe.style.display = 'none';
                    placeholder.style.display = 'block';
                    placeholder.innerHTML = `
                        <div style="background: #0d1117; color: #c9d1d9; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 12px; line-height: 1.4; max-height: 350px; overflow-y: auto;">
                            <div style="color: #58a6ff; margin-bottom: 10px; font-weight: bold;">Decoded HTML Content:</div>
                            <pre style="margin: 0; white-space: pre-wrap;">${this.decodedHTML.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
                        </div>
                    `;
                    this.log('Showing HTML as formatted text (fallback)', 'info');
                } else {
                    // Show placeholder when no HTML yet
                    placeholder.style.display = 'block';
                    iframe.style.display = 'none';
                    this.log('No HTML content to display yet', 'info');
                }
            }
            
            log(message, type = 'info') {
                const logContainer = document.getElementById('decoderLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                
                const timestamp = new Date().toLocaleTimeString();
                const typeClass = type === 'element' ? 'log-element' : 
                                 type === 'success' ? 'log-element' :
                                 type === 'error' ? 'log-frequency' : 'log-text';
                
                entry.innerHTML = `
                    <span class="log-timestamp">${timestamp}</span> - 
                    <span class="${typeClass}">${message}</span>
                `;
                
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Keep only last 100 entries
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }
            
            updateStatus(message, type = 'info') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }
            
            stopDecoding() {
                this.isDecoding = false;
                
                if (this.source && this.source.mediaStream) {
                    this.source.mediaStream.getTracks().forEach(track => track.stop());
                }
                
                if (this.source && this.source.stop) {
                    this.source.stop();
                }
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                
                this.updateStatus('Decoding stopped', 'info');
                this.log('Decoder stopped by user', 'info');
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            new ProductionSoundDecoder();
        });

        // Navbar scroll effect
        window.addEventListener('scroll', function() {
            const navbar = document.getElementById('navbar');
            if (window.scrollY > 50) {
                navbar.classList.add('scrolled');
            } else {
                navbar.classList.remove('scrolled');
            }
        });
    </script>
</body>
</html>