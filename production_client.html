<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protocol % Production Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            background: #0d1117;
            color: #c9d1d9;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            padding: 40px 0;
            border-bottom: 1px solid #21262d;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            color: #58a6ff;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #8b949e;
            font-size: 1.1rem;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-panel {
            background: #161b22;
            border: 1px solid #21262d;
            border-radius: 8px;
            padding: 20px;
        }
        
        .control-panel h3 {
            color: #f0f6fc;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #f0f6fc;
            font-weight: 500;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px 12px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-family: inherit;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #58a6ff;
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
        }
        
        .btn {
            background: #238636;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background: #2ea043;
        }
        
        .btn:disabled {
            background: #21262d;
            color: #6e7681;
            cursor: not-allowed;
        }
        
        .btn-danger {
            background: #da3633;
        }
        
        .btn-danger:hover {
            background: #f85149;
        }
        
        .status {
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: 500;
        }
        
        .status.success {
            background: rgba(35, 134, 54, 0.15);
            border: 1px solid #238636;
            color: #3fb950;
        }
        
        .status.error {
            background: rgba(218, 54, 51, 0.15);
            border: 1px solid #da3633;
            color: #f85149;
        }
        
        .status.info {
            background: rgba(88, 166, 255, 0.15);
            border: 1px solid #58a6ff;
            color: #79c0ff;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: #161b22;
            border: 1px solid #21262d;
            border-radius: 8px;
            padding: 20px;
        }
        
        .panel h3 {
            color: #f0f6fc;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        canvas {
            width: 100%;
            height: 200px;
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 6px;
            margin-bottom: 10px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .metric {
            text-align: center;
            padding: 10px;
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 6px;
        }
        
        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #58a6ff;
        }
        
        .metric-label {
            font-size: 0.8rem;
            color: #8b949e;
        }
        
        .decoder-output {
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 6px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.9rem;
        }
        
        .preview-area {
            grid-column: 1 / -1;
        }
        
        .html-preview {
            background: #ffffff;
            color: #24292f;
            padding: 20px;
            border-radius: 6px;
            min-height: 200px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
        }
        
        .frequency-bar {
            height: 4px;
            background: #21262d;
            border-radius: 2px;
            margin: 5px 0;
            position: relative;
        }
        
        .frequency-bar .active {
            height: 100%;
            background: linear-gradient(90deg, #238636, #58a6ff);
            border-radius: 2px;
            transition: width 0.1s;
        }
        
        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid #21262d;
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .log-timestamp {
            color: #6e7681;
            font-size: 0.8rem;
        }
        
        .log-frequency {
            color: #58a6ff;
            font-weight: 500;
        }
        
        .log-element {
            color: #3fb950;
        }
        
        .log-text {
            color: #f0f6fc;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Protocol % Production Client</h1>
            <p>Real-time HTML decoding from audio signals</p>
        </div>
        
        <div class="controls">
            <div class="control-panel">
                <h3>Audio Source</h3>
                <div class="form-group">
                    <label for="sourceType">Source Type</label>
                    <select id="sourceType">
                        <option value="file">Audio File</option>
                        <option value="microphone">Live Microphone</option>
                        <option value="server">Server Stream</option>
                        <option value="url">Remote URL</option>
                    </select>
                </div>
                <div class="form-group" id="fileGroup">
                    <label for="audioFile">Select Audio File</label>
                    <input type="file" id="audioFile" accept="audio/*">
                </div>
                <div class="form-group" id="serverGroup" style="display: none;">
                    <label for="serverFile">HTML Filename</label>
                    <input type="text" id="serverFile" placeholder="example.html">
                </div>
                <div class="form-group" id="urlGroup" style="display: none;">
                    <label for="remoteUrl">Remote URL</label>
                    <input type="url" id="remoteUrl" placeholder="https://example.com/audio.wav">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button id="startBtn" class="btn">Start Decoding</button>
                    <button id="stopBtn" class="btn btn-danger" disabled>Stop</button>
                </div>
            </div>
            
            <div class="control-panel">
                <h3>Decoder Settings</h3>
                <div class="form-group">
                    <label for="decoderMode">Mode</label>
                    <select id="decoderMode">
                        <option value="production">Production</option>
                        <option value="ultrasonic">Ultrasonic</option>
                        <option value="debug">Debug</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="fftSize">FFT Size</label>
                    <select id="fftSize">
                        <option value="2048">2048</option>
                        <option value="4096" selected>4096</option>
                        <option value="8192">8192</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="threshold">Detection Threshold</label>
                    <input type="range" id="threshold" min="0" max="100" value="30">
                </div>
                <div class="form-group">
                    <label for="smoothing">Smoothing</label>
                    <input type="range" id="smoothing" min="0" max="1" step="0.1" value="0.3">
                </div>
            </div>
            
            <div class="control-panel">
                <h3>Status & Metrics</h3>
                <div id="status" class="status info">Ready to decode</div>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="dominantFreq">-</div>
                        <div class="metric-label">Frequency (Hz)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="signalStrength">-</div>
                        <div class="metric-label">Signal (dB)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="decodedElements">0</div>
                        <div class="metric-label">Elements</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="errorRate">0%</div>
                        <div class="metric-label">Error Rate</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="panel">
                <h3>Audio Analysis</h3>
                <canvas id="waveformCanvas"></canvas>
                <canvas id="spectrogramCanvas"></canvas>
                <div class="frequency-bar">
                    <div class="active" id="frequencyIndicator"></div>
                </div>
            </div>
            
            <div class="panel">
                <h3>Decoder Log</h3>
                <div class="decoder-output" id="decoderLog">
                    <div class="log-entry">
                        <span class="log-timestamp">Ready</span> - 
                        <span class="log-text">Waiting for audio input...</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="preview-area panel">
            <h3>Live HTML Preview</h3>
            <iframe class="html-preview" id="htmlPreview" style="width: 100%; height: 400px; border: 1px solid #21262d; border-radius: 6px;">
            </iframe>
            <div id="htmlPreviewPlaceholder" class="html-preview" style="display: block;">
                <p style="color: #6e7681; font-style: italic;">
                    Decoded HTML will appear here in real-time as audio is processed...
                </p>
            </div>
        </div>
    </div>

    <script>
        class ProductionSoundDecoder {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.source = null;
                this.isDecoding = false;
                this.frequencies = {};
                this.decodedHTML = '';
                this.elementCount = 0;
                this.errorCount = 0;
                this.lastFrequency = 0;
                this.frequencyBuffer = [];
                this.state = 'waiting';
                this.htmlStack = [];
                this.currentElement = null;
                this.frameStarted = false;
                
                this.initializeEventListeners();
                this.loadFrequencyMap();
            }
            
            async loadFrequencyMap() {
                // Use default frequencies directly - no server needed
                this.frequencies = this.getDefaultFrequencies();
                this.log('Frequency map loaded', 'success');
            }
            
            getDefaultFrequencies() {
                return {
                    frame_start: [440, 554, 659],
                    frame_end: [440, 349, 262],
                    http_200: [523, 659, 784],
                    html_open: 440,
                    html_close: 415,
                    head_open: 660,
                    head_close: 622,
                    body_open: 880,
                    body_close: 831,
                    title: [523, 659, 784, 1047],
                    h1: 1047,
                    h2: 932,
                    h3: 831,
                    p: 698,
                    div: 622,
                    a: [392, 494, 587],
                    fsk_0: 2000,
                    fsk_1: 2400,
                    sync: 2800,
                    block_start: 1760,
                    block_end: 1568
                };
            }
            
            initializeEventListeners() {
                document.getElementById('sourceType').addEventListener('change', this.handleSourceChange.bind(this));
                document.getElementById('startBtn').addEventListener('click', this.startDecoding.bind(this));
                document.getElementById('stopBtn').addEventListener('click', this.stopDecoding.bind(this));
                document.getElementById('decoderMode').addEventListener('change', this.updateDecoderSettings.bind(this));
                document.getElementById('threshold').addEventListener('input', this.updateDecoderSettings.bind(this));
                document.getElementById('smoothing').addEventListener('input', this.updateDecoderSettings.bind(this));
            }
            
            handleSourceChange() {
                const sourceType = document.getElementById('sourceType').value;
                
                document.getElementById('fileGroup').style.display = sourceType === 'file' ? 'block' : 'none';
                document.getElementById('serverGroup').style.display = sourceType === 'server' ? 'block' : 'none';
                document.getElementById('urlGroup').style.display = sourceType === 'url' ? 'block' : 'none';
            }
            
            updateDecoderSettings() {
                if (this.analyser) {
                    const smoothing = parseFloat(document.getElementById('smoothing').value);
                    this.analyser.smoothingTimeConstant = smoothing;
                }
            }
            
            async startDecoding() {
                try {
                    this.updateStatus('Initializing audio context...', 'info');
                    
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    const sourceType = document.getElementById('sourceType').value;
                    
                    switch (sourceType) {
                        case 'file':
                            await this.loadAudioFile();
                            break;
                        case 'microphone':
                            await this.startMicrophoneCapture();
                            break;
                        case 'server':
                            await this.fetchFromServer();
                            break;
                        case 'url':
                            await this.fetchFromURL();
                            break;
                    }
                    
                    this.setupAnalyser();
                    this.isDecoding = true;
                    this.startAnalysis();
                    
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    
                    this.updateStatus('Decoding audio...', 'success');
                    
                } catch (error) {
                    this.updateStatus('Error: ' + error.message, 'error');
                    this.log('Decoder error: ' + error.message, 'error');
                }
            }
            
            async loadAudioFile() {
                const fileInput = document.getElementById('audioFile');
                if (!fileInput.files[0]) {
                    throw new Error('Please select an audio file');
                }
                
                this.updateStatus('Loading audio file...', 'info');
                
                const arrayBuffer = await fileInput.files[0].arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                
                this.source = this.audioContext.createBufferSource();
                this.source.buffer = audioBuffer;
                this.source.loop = false;
                
                this.log(`Loaded audio file: ${fileInput.files[0].name}`, 'success');
            }
            
            async startMicrophoneCapture() {
                this.updateStatus('Requesting microphone access...', 'info');
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 44100,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });
                
                this.source = this.audioContext.createMediaStreamSource(stream);
                this.log('Microphone capture started', 'success');
            }
            
            async fetchFromServer() {
                throw new Error('Server mode not available in standalone version');
            }
            
            async fetchFromURL() {
                const url = document.getElementById('remoteUrl').value;
                if (!url) {
                    throw new Error('Please enter a URL');
                }
                
                this.updateStatus('Fetching from URL...', 'info');
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch: ${response.status}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                
                this.source = this.audioContext.createBufferSource();
                this.source.buffer = audioBuffer;
                
                this.log(`Fetched from URL: ${url}`, 'success');
            }
            
            setupAnalyser() {
                const fftSize = parseInt(document.getElementById('fftSize').value);
                const smoothing = parseFloat(document.getElementById('smoothing').value);
                
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = fftSize;
                this.analyser.smoothingTimeConstant = smoothing;
                this.analyser.minDecibels = -90;
                this.analyser.maxDecibels = -10;
                
                if (this.source) {
                    this.source.connect(this.analyser);
                    
                    if (this.source.start) {
                        this.source.start(0);
                    }
                }
            }
            
            startAnalysis() {
                const bufferLength = this.analyser.frequencyBinCount;
                const frequencyData = new Uint8Array(bufferLength);
                const timeData = new Uint8Array(bufferLength);
                
                const analyze = () => {
                    if (!this.isDecoding) return;
                    
                    this.analyser.getByteFrequencyData(frequencyData);
                    this.analyser.getByteTimeDomainData(timeData);
                    
                    this.updateVisualizations(frequencyData, timeData);
                    this.processAudioData(frequencyData);
                    
                    requestAnimationFrame(analyze);
                };
                
                analyze();
            }
            
            updateVisualizations(frequencyData, timeData) {
                this.drawWaveform(timeData);
                this.drawSpectrogram(frequencyData);
                this.updateMetrics(frequencyData);
            }
            
            drawWaveform(timeData) {
                const canvas = document.getElementById('waveformCanvas');
                const ctx = canvas.getContext('2d');
                const width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                const height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, width, height);
                
                ctx.strokeStyle = '#58a6ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const sliceWidth = (width / window.devicePixelRatio) / timeData.length;
                let x = 0;
                
                for (let i = 0; i < timeData.length; i++) {
                    const v = timeData[i] / 128.0;
                    const y = v * (height / window.devicePixelRatio) / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
            }
            
            drawSpectrogram(frequencyData) {
                const canvas = document.getElementById('spectrogramCanvas');
                const ctx = canvas.getContext('2d');
                const width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                const height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                // Shift existing data left
                const imageData = ctx.getImageData(1, 0, width - 1, height);
                ctx.putImageData(imageData, 0, 0);
                
                // Draw new column
                const displayWidth = width / window.devicePixelRatio;
                const displayHeight = height / window.devicePixelRatio;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    const value = frequencyData[i];
                    const percent = value / 255;
                    
                    // Color mapping: blue (low) to red (high)
                    const hue = (1 - percent) * 240;
                    const saturation = 100;
                    const lightness = percent * 50;
                    
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    
                    const y = displayHeight - (i / frequencyData.length) * displayHeight;
                    const barHeight = displayHeight / frequencyData.length;
                    
                    ctx.fillRect(displayWidth - 1, y, 1, barHeight);
                }
            }
            
            updateMetrics(frequencyData) {
                // Find dominant frequency
                let maxIndex = 0;
                let maxValue = 0;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    if (frequencyData[i] > maxValue) {
                        maxValue = frequencyData[i];
                        maxIndex = i;
                    }
                }
                
                const frequency = (maxIndex * this.audioContext.sampleRate) / (this.analyser.fftSize * 2);
                const strength = 20 * Math.log10(maxValue / 255);
                
                document.getElementById('dominantFreq').textContent = frequency.toFixed(1);
                document.getElementById('signalStrength').textContent = strength.toFixed(1);
                document.getElementById('decodedElements').textContent = this.elementCount;
                
                const errorRate = this.elementCount > 0 ? (this.errorCount / this.elementCount * 100) : 0;
                document.getElementById('errorRate').textContent = errorRate.toFixed(1) + '%';
                
                // Update frequency indicator
                const indicator = document.getElementById('frequencyIndicator');
                const maxFreq = this.audioContext.sampleRate / 2;
                const percent = (frequency / maxFreq) * 100;
                indicator.style.width = percent + '%';
            }
            
            processAudioData(frequencyData) {
                const threshold = parseInt(document.getElementById('threshold').value);
                const dominantFreq = this.getDominantFrequency(frequencyData, threshold);
                
                if (dominantFreq > 0 && Math.abs(dominantFreq - this.lastFrequency) > 100) {
                    this.lastFrequency = dominantFreq;
                    
                    const element = this.identifyElement(dominantFreq);
                    
                    if (element && this.shouldProcessElement(element)) {
                        this.processElement(element, dominantFreq);
                    }
                }
            }
            
            shouldProcessElement(element) {
                const now = Date.now();
                if (!this.lastElementTime) this.lastElementTime = {};
                
                // Prevent same element from being processed too frequently
                if (this.lastElementTime[element] && (now - this.lastElementTime[element]) < 500) {
                    return false;
                }
                
                this.lastElementTime[element] = now;
                return true;
            }
            
            getDominantFrequency(frequencyData, threshold) {
                let maxIndex = 0;
                let maxValue = 0;
                
                for (let i = 0; i < frequencyData.length; i++) {
                    if (frequencyData[i] > maxValue && frequencyData[i] > threshold) {
                        maxValue = frequencyData[i];
                        maxIndex = i;
                    }
                }
                
                if (maxValue < threshold) return 0;
                
                return (maxIndex * this.audioContext.sampleRate) / (this.analyser.fftSize * 2);
            }
            
            identifyElement(frequency) {
                const tolerance = 30; // Tighter tolerance for better accuracy
                let bestMatch = null;
                let bestDistance = Infinity;
                
                for (const [element, freq] of Object.entries(this.frequencies)) {
                    if (Array.isArray(freq)) {
                        for (const f of freq) {
                            const distance = Math.abs(frequency - f);
                            if (distance < tolerance && distance < bestDistance) {
                                bestMatch = element;
                                bestDistance = distance;
                            }
                        }
                    } else {
                        const distance = Math.abs(frequency - freq);
                        if (distance < tolerance && distance < bestDistance) {
                            bestMatch = element;
                            bestDistance = distance;
                        }
                    }
                }
                
                return bestMatch;
            }
            
            processElement(element, frequency) {
                this.elementCount++;
                this.log(`${frequency.toFixed(1)}Hz ‚Üí ${element}`, 'element');
                
                // Initialize HTML structure if not already done
                if (!this.decodedHTML || this.decodedHTML.length === 0) {
                    this.decodedHTML = '<!DOCTYPE html>\n<html>\n<head>\n<title>Decoded from Audio</title>\n</head>\n<body>\n<h1>üéµ Audio Protocol Decoder</h1>\n';
                    this.state = 'decoding';
                    this.log('HTML structure initialized', 'success');
                    this.updateHTMLPreview(); // Force update immediately
                }
                
                switch (element) {
                    case 'frame_start':
                        if (this.state !== 'decoding') {
                            this.decodedHTML = '<!DOCTYPE html>\n<html>\n<head>\n<title>Frame Started</title>\n</head>\n<body>\n<h1>üöÄ Frame Started</h1>\n';
                            this.state = 'decoding';
                            this.log('Frame started - building HTML structure', 'success');
                        }
                        this.decodedHTML += '<p>‚úÖ Frame initialization complete</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'http_200':
                        this.log('HTTP 200 OK received', 'success');
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<div style="background: #d4edda; color: #155724; padding: 10px; margin: 5px 0; border-radius: 4px;">üì° HTTP 200 OK - Connection successful</div>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'html_open':
                        this.decodedHTML += '<p>üè∑Ô∏è HTML document opened</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'head_open':
                        this.decodedHTML += '<p>üß† Head section opened</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'title':
                        this.decodedHTML += '<p>üìù Title element processed</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'head_close':
                        this.decodedHTML += '<p>üß† Head section closed</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'body_open':
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<div style="background: #cce5ff; color: #004085; padding: 15px; margin: 10px 0; border-radius: 8px;">\n';
                            this.decodedHTML += '<h2>üéØ Body Section Detected!</h2>\n';
                            this.decodedHTML += '<p>This content was successfully decoded from audio frequencies.</p>\n';
                            this.decodedHTML += '<p><strong>Frequency:</strong> ' + frequency.toFixed(1) + 'Hz</p>\n';
                            this.decodedHTML += '</div>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'h1':
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<h1 style="color: #007bff;">üéµ Hello from Audio Signal!</h1>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'p':
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<p style="font-size: 16px; color: #333;">üìª This paragraph was transmitted via audio protocol</p>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'body_close':
                        this.decodedHTML += '<p>üèÅ Body section closing...</p>\n';
                        this.updateHTMLPreview();
                        break;
                        
                    case 'html_close':
                        if (this.state === 'decoding') {
                            this.decodedHTML += '<div style="background: #f8f9fa; color: #495057; padding: 15px; margin: 10px 0; border-radius: 8px; border: 2px solid #28a745;">\n';
                            this.decodedHTML += '<h3>üéâ HTML Document Complete!</h3>\n';
                            this.decodedHTML += '<p>Successfully decoded complete HTML structure from audio signal.</p>\n';
                            this.decodedHTML += '<p><em>Transmission completed at ' + new Date().toLocaleTimeString() + '</em></p>\n';
                            this.decodedHTML += '</div>\n';
                            
                            // Ensure proper closing
                            if (!this.decodedHTML.includes('</body>')) {
                                this.decodedHTML += '</body>\n';
                            }
                            if (!this.decodedHTML.includes('</html>')) {
                                this.decodedHTML += '</html>';
                            }
                            this.log('HTML document completed!', 'success');
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    case 'frame_end':
                        this.state = 'complete';
                        this.log('Frame completed successfully', 'success');
                        this.updateStatus('Decoding completed - HTML structure built!', 'success');
                        // Add final completion message
                        if (this.decodedHTML && !this.decodedHTML.includes('Frame completed')) {
                            this.decodedHTML += '<div style="background: #28a745; color: white; padding: 20px; margin: 10px 0; border-radius: 8px; text-align: center;">\n';
                            this.decodedHTML += '<h2>‚ú® TRANSMISSION COMPLETE ‚ú®</h2>\n';
                            this.decodedHTML += '<p>All audio signals successfully decoded!</p>\n';
                            this.decodedHTML += '</div>\n';
                            this.updateHTMLPreview();
                        }
                        break;
                        
                    default:
                        if (this.state === 'decoding') {
                            this.decodedHTML += `<div style="background: #fff3cd; color: #856404; padding: 8px; margin: 3px 0; border-radius: 4px;">üîç Signal: ${element} (${frequency.toFixed(1)}Hz)</div>\n`;
                            this.updateHTMLPreview();
                        }
                        this.log(`Processing: ${element}`, 'info');
                }
            }
            
            updateHTMLPreview() {
                const iframe = document.getElementById('htmlPreview');
                const placeholder = document.getElementById('htmlPreviewPlaceholder');
                
                // Always log what we're trying to display
                this.log(`Updating preview - HTML length: ${this.decodedHTML ? this.decodedHTML.length : 0}`, 'info');
                
                if (this.decodedHTML && this.decodedHTML.trim().length > 0) {
                    // Hide placeholder and show iframe
                    placeholder.style.display = 'none';
                    iframe.style.display = 'block';
                    
                    // Method 1: Try srcdoc first (more reliable)
                    try {
                        iframe.srcdoc = this.decodedHTML;
                        this.log('HTML written to iframe via srcdoc', 'success');
                        return;
                    } catch (error) {
                        this.log('srcdoc failed: ' + error.message, 'error');
                    }
                    
                    // Method 2: Try contentDocument.write
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        if (iframeDoc) {
                            iframeDoc.open();
                            iframeDoc.write(this.decodedHTML);
                            iframeDoc.close();
                            this.log('HTML written to iframe via document.write', 'success');
                            return;
                        }
                    } catch (error) {
                        this.log('document.write failed: ' + error.message, 'error');
                    }
                    
                    // Method 3: Fallback - show as formatted text
                    iframe.style.display = 'none';
                    placeholder.style.display = 'block';
                    placeholder.innerHTML = `
                        <div style="background: #0d1117; color: #c9d1d9; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 12px; line-height: 1.4; max-height: 350px; overflow-y: auto;">
                            <div style="color: #58a6ff; margin-bottom: 10px; font-weight: bold;">üìÑ Decoded HTML Content:</div>
                            <pre style="margin: 0; white-space: pre-wrap;">${this.decodedHTML.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
                        </div>
                    `;
                    this.log('Showing HTML as formatted text (fallback)', 'info');
                } else {
                    // Show placeholder when no HTML yet
                    placeholder.style.display = 'block';
                    iframe.style.display = 'none';
                    this.log('No HTML content to display yet', 'info');
                }
            }
            
            log(message, type = 'info') {
                const logContainer = document.getElementById('decoderLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                
                const timestamp = new Date().toLocaleTimeString();
                const typeClass = type === 'element' ? 'log-element' : 
                                 type === 'success' ? 'log-element' :
                                 type === 'error' ? 'log-frequency' : 'log-text';
                
                entry.innerHTML = `
                    <span class="log-timestamp">${timestamp}</span> - 
                    <span class="${typeClass}">${message}</span>
                `;
                
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Keep only last 100 entries
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }
            
            updateStatus(message, type = 'info') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }
            
            stopDecoding() {
                this.isDecoding = false;
                
                if (this.source && this.source.mediaStream) {
                    this.source.mediaStream.getTracks().forEach(track => track.stop());
                }
                
                if (this.source && this.source.stop) {
                    this.source.stop();
                }
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                
                this.updateStatus('Decoding stopped', 'info');
                this.log('Decoder stopped by user', 'info');
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            new ProductionSoundDecoder();
        });
    </script>
</body>
</html>